from cex_analysis.cut_factory import CutFactory
from cex_analysis.event_selection_base import EventSelectionBase
from cex_analysis.histograms import Histogram
from cex_analysis.efficiency_data import EfficiencyData
import awkward as ak

from pathlib import Path
import pkgutil
import importlib


class EventHandler:
    def __init__(self, config):

        self.config = config

        # Create the Cut Factory to assemble the cuts
        self.build_ana = CutFactory()

        # Hold the class references in these maps
        self.all_cut_classes = {}
        self.get_all_cut_classes()

        # Now assemble our cuts
        self.cut_map = {}
        self.create_analysis()

        # Initialize the histogram class for this instance of EventHandler
        self.Hist_object = Histogram(config=config)

        # Initialize the efficiency data class
        self.efficiency = EfficiencyData(num_true_process=0, cut_efficiency_dict={}, cut_total_dict={})

    def get_all_cut_classes(self):
        """
        1. Get all the modules located in the package directory so we can import them
        2. Get all the subclasses of EventSelectionBase since these are the Cut classes
        :return:
        """
        # Get all available Cut classes and import them
        pkg_dir = Path(__file__).parent
        print("Importing all subclasses from:", pkg_dir)

        for (module_loader, name, ispkg) in pkgutil.iter_modules([pkg_dir]):
            print("Importing module: [", name, "]")
            importlib.import_module('.' + name, __package__)

        self.all_cut_classes = {cls.__name__: cls for cls in EventSelectionBase.__subclasses__()}

    def create_analysis(self):
        """
        Create the analysis chain by creating an instance of each Cut class
        :param config:
        :return:
        """
        for cut_class in self.config["cut_list"]:
            if cut_class in self.all_cut_classes:
                # If the cut class is available then register and create it from the factory
                self.build_ana.register_builder(cut_class, self.all_cut_classes[cut_class])
                self.cut_map[cut_class] = self.build_ana.create(cut_class, self.config)
            else:
                print("Cut class", cut_class, "not found!")

    def run_selection(self, events):
        """
        Here we run the selection. This means we loop over each cut
        passing the data and receving a selection mask from it in
        sequential order.
        :param events: Array of events to be analyzed
        :return:
        """
        true_process_mask = self.get_num_true_process_events(events)
        self.efficiency.set_num_true_process(ak.sum(true_process_mask, axis=0))
        # Add a column which specifies whether this is a true process
        events["true_cex_event"] = true_process_mask
        test = ak.sum(events["true_cex_event"], axis=0)

        for i, cut in enumerate(self.cut_map):
            print("Processing cut:", cut, " Num", len(events))
            # Combine the masks
            if i == 0:
                event_mask = self.cut_map[cut].selection(events, self.Hist_object)
            else:
                events = events[event_mask]
                print("Processing cut2:", cut, " Num", len(events))
                event_mask = self.cut_map[cut].selection(events, self.Hist_object)

            # Keep track of selection efficiency
            num_true_selected = ak.sum(events["true_cex_event", event_mask], axis=0)
            num_total_selected = ak.sum(event_mask, axis=0)

            self.efficiency.add_cut_selection(cut_name=cut,
                                              num_true_selected=num_true_selected,
                                              num_total_selected=num_total_selected)

            print("Cut", cut, " True selected", num_true_selected, "events. Total selected", num_total_selected,
                  "(", ak.sum(true_process_mask, axis=0), ")", test)

        # Return all the histograms generated by the selection and the mask
        return self.Hist_object.get_hist_map(), event_mask, self.efficiency.cut_efficiency_dict, \
               self.efficiency.cut_total_dict, self.efficiency.num_true_process

    @staticmethod
    def get_num_true_process_events(events):
        # This is very specific to the analysis and therefore not abstracted
        # bool IsHEChargedPion = (true_daughter_nPiMinus > 0 || true_daughter_nPiPlus > 0) && he_pion;
        # TODO add high energy charged pion selection
        high_energy_charged_pion = (events["true_daughter_nPiMinus"] > 0) | (events["true_daughter_nPiPlus"] > 0)

        daughter_select = (events["true_daughter_nPiMinus"] == 0) & (events["true_daughter_nPiPlus"] == 0) & \
                          (events["true_daughter_nPi0"] == 1) & \
                          ((events["true_daughter_nProton"] > 0) | (events["true_daughter_nNeutron"] > 0))

        true_charge_exchange = (events["true_beam_PDG"] == 211) & (events["true_beam_endProcess"] == "pi+Inelastic") \
                               & daughter_select

        return true_charge_exchange
