from cex_analysis.cut_factory import CutFactory
from cex_analysis.event_selection_base import EventSelectionBase
from cex_analysis.histograms import Histogram
from cex_analysis.efficiency_data import EfficiencyData
from cex_analysis.true_process import TrueProcess
import awkward as ak

from pathlib import Path
import pkgutil
import importlib


class EventHandler:
    def __init__(self, config):

        self.config = config

        # Create the Cut Factory to assemble the cuts
        self.build_ana = CutFactory()

        # Hold the class references in these maps
        self.all_cut_classes = {}
        self.get_all_cut_classes()

        # Now assemble our cuts
        self.cut_map = {}
        self.create_analysis()

        # Initialize the histogram class for this instance of EventHandler
        self.Hist_object = Histogram(config=config)

        # Initialize the efficiency data class
        self.efficiency = EfficiencyData(num_true_process=0, cut_efficiency_dict={}, cut_total_dict={})

    def get_all_cut_classes(self):
        """
        1. Get all the modules located in the package directory so we can import them
        2. Get all the subclasses of EventSelectionBase since these are the Cut classes
        :return:
        """
        # Get all available Cut classes and import them
        pkg_dir = Path(__file__).parent
        print("Importing all subclasses from:", pkg_dir)

        for (module_loader, name, ispkg) in pkgutil.iter_modules([pkg_dir]):
            print("Importing module: [", name, "]")
            importlib.import_module('.' + name, __package__)

        self.all_cut_classes = {cls.__name__: cls for cls in EventSelectionBase.__subclasses__()}

    def create_analysis(self):
        """
        Create the analysis chain by creating an instance of each Cut class
        :param config:
        :return:
        """
        for cut_class in self.config["cut_list"]:
            if cut_class in self.all_cut_classes:
                # If the cut class is available then register and create it from the factory
                self.build_ana.register_builder(cut_class, self.all_cut_classes[cut_class])
                self.cut_map[cut_class] = self.build_ana.create(cut_class, self.config)
            else:
                print("Cut class", cut_class, "not found!")

    def run_selection(self, events):
        """
        Here we run the selection. This means we loop over each cut
        passing the data and receving a selection mask from it in
        sequential order.
        :param events: Array of events to be analyzed
        :return:
        """
        # Add the interaction process columns
        classify_process = TrueProcess()
        events = classify_process.classify_event_process(events=events)

        # Get total number of true signal events
        true_total_single_cex = ak.sum(events["single_charge_exchange"], axis=0)
        self.efficiency.set_num_true_process(true_total_single_cex)

        for i, cut in enumerate(self.cut_map):
            print("Processing cut:", cut, " Num", len(events))
            # Combine the masks
            if i == 0:
                event_mask = self.cut_map[cut].selection(events, self.Hist_object)
            else:
                events = events[event_mask]
                print("Processing cut2:", cut, " Num", len(events))
                event_mask = self.cut_map[cut].selection(events, self.Hist_object)

            # Keep track of selection efficiency
            num_true_selected = ak.sum(events["single_charge_exchange", event_mask], axis=0)
            num_total_selected = ak.sum(event_mask, axis=0)

            self.efficiency.add_cut_selection(cut_name=cut,
                                              num_true_selected=num_true_selected,
                                              num_total_selected=num_total_selected)

            print("Cut", cut, " True selected", num_true_selected, "events. Total selected", num_total_selected,
                  "(", true_total_single_cex, ")")

        # Return all the histograms generated by the selection and the mask
        return self.Hist_object.get_hist_map(), event_mask, self.efficiency.cut_efficiency_dict, \
               self.efficiency.cut_total_dict, self.efficiency.num_true_process
